---
title: Graphs
category: data structures
breadcrumbs: 
  - courses
  - javascript
description: All about Graphs in Javascript
---

A graph is a connection of nodes data structure. Each node is called a `vertex` and the connection between them are called `edges`.

Formally, a graph `G=(V,E)` is a finite set of vertices V and a set of edges E. Each edge is a pair (v, u) where v, u are elements of V.

A graph can be represented in two ways:

- Adjacent Matrix:
  A 2-D array of size V x V where V is the number of vertices in the graph and the value of an entry `adj[i][j]` is either 1 or 0. A value of 1 indicates that there is an edge from vertex i to vertex j, otherwise 0.

- Adjacent List:
 An array of list. In Javascript, this can be easily represnted using an object of key values, where the key is the node and the value are the nodes it is connected to. **I would highly recommend using this representation for Graphs âœ….**

It is also important to note that there are two types of graphs:

`Directed Graphs`
- Edges have a direction.

![Directed Graph](https://i.stack.imgur.com/UIvbz.png) 

```javascript
V = {V1, V2, V3, V4}
E = {(V1, V2), (V2, V3), (V3, V2), (V4, V1)}
```

`Undirected Graphs` 
- Edges do not have a direction.

![Undirected Graph](https://i0.wp.com/pediaa.com/wp-content/uploads/2019/01/Difference-Between-Directed-and-Undirected-Graph_Figure-2.png?resize=550%2C400)

```javascript
V = {V1, V2, V3, V4}
E = {(V1, V2), (V1, V3), (V2, V3), (V3, V4)}
```

## From Edges to Adjacent List

Sometimes, in an coding interview, we are given the edges of a graph. A good way to represent the graph is using an adjacent list.

```javascript showLineNumbers
// Given input of edges
const edges = [
  [0, 1],
  [1, 2],
  [2, 3],
  [3, 0],
  [2, 0]
];

function buildGraph(edges) {
  const graph = {}

  for (let [a,b] of edges) {
    if (!(a in graph)) graph[a] = [];
    if (!(b in graph)) graph[b] = [];
    graph[a].push(b);
    graph[b].push(a);
  }

  return graph
}
/* {
  0: [1, 3, 2],
  1: [0, 2],
  2: [1, 3, 0],
  3: [2, 0]
} */ 
```
## Acylic Graphs

### Depth First Search (DFS)

DFS is a graph traversal algorithm. It starts at the `start` node and explores as deep as possible along each branch before backtracking. We can implement DFS using a stack or recursion.

![DFS](https://codeforces.com/predownloaded/8d/be/8dbe5d89e58b67f3d8e4d8e0e8eb3358ba921b28.png)

#### `DFS Stack`

```javascript filePath=app/jsx showLineNumbers
function dfs(graph, source) {
  let stack = [source];

  while (stack.length > 0) {
    let current = stack.pop();
    
    console.log('Do something', current);

    for (let neighbor of graph[current]) {
      stack.push(neighbor);
    }
  }
}
```

#### `DFS Recursively`

```javascript showLineNumbers
function dfs(graph, source) {

  console.log('Do something', source);

  for (let neighbor of graph[source]) {
    dfs(graph, neighbor);
  }
}
```

<Callout title="Note">
 We assume the graph is acyclic (no cycles). If the graph is cyclic, we need to keep track of visited nodes using `new Set()` to avoid infinite loops.
</Callout>

### Breadth First Search (BFS)

BFS is a graph traversal algorithm. It starts at the `start` node and explores all of its neighbors before moving on to the nodes at the next depth level. **The only way to implement BFS is using a queue**.

![BFS](https://lh5.googleusercontent.com/JKY4V8OZEs5L68Mh2ZY5ZqiqGkaj8esWnTEUwEdygFQdRFowh7aCWpibaPRqkcR3SHBh2Q4Io856f2fAzM5Ae3nD2uLj7AEU3NnQfZ55E2ni0EzXceoVTJtHzqGlUhQ9-izy5Y0v1DK0xIQ4vUxs9Ds)

#### `Queue BFS`
